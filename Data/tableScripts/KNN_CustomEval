import pandas as pd 
import numpy as np
import math
from alive_progress import alive_bar

import ipywidgets as widgets
widgets.IntSlider()

import threading, queue


import common
from Data import JoinedData

# Loading Data
cleanData = common.loadFile("CleanedData").drop(['RID', 'VISCODE', 'PTEDUCAT', 'PTGENDER', 'AGE'], axis=1) # Dropping fields not used
allData = JoinedData().data.drop_duplicates()

allData = allData.drop([x for x in list(allData) if x not in list(cleanData)], axis=1) # Drops fields that don't exist in cleanData
allData = allData[(allData.DX.notna()) & (allData.DX != '')] # Remove rows without diagnosis (This is the field we use to validate)
allData = pd.merge(allData, cleanData, how="left", indicator=True).query("_merge != 'both'").drop('_merge', axis=1).reset_index(drop=True) # Removing cleanData rows from allData
allData.replace('', np.NaN, inplace=True) # Remove empty string values with np.NaN to make it easier to detect later

allData = allData.astype("float")
cleanData = cleanData.astype("float")


def distance(a, b):
    return math.sqrt(a**2 + b**2)


# Function for incomplete fitting
def incompleteFitting(completeDataset: pd.DataFrame, incompleteData: pd.DataFrame, k: int, missingColumns: int) -> list:
    frequent= []
    currentData = incompleteData.dropna(thresh=incompleteData.shape[1]-missingColumns, axis=0)
    with alive_bar(len(currentData)) as bar:
        for i in range(len(currentData)):
            currentRow = currentData.iloc[[i]]
            labels = [x for x in list(currentRow) if currentRow[x].isna().all()]
            labels.append('DX') # Not using diagnostic for this calc (variable we want to compare)
            data = pd.DataFrame(completeDataset[x].apply(lambda y: distance(y, currentRow[x])) if x not in labels else completeDataset[x] for x in currentRow.columns).T
            data["TOTALS"] = data.drop(labels, axis=1).sum(axis=1)
            data = data.sort_values(by=["TOTALS"])
            best = list(data.DX[:k])


            result = max(set(best), key = best.count)
            frequent.append(result==currentRow.DX)
            bar()

    return frequent

print(incompleteFitting(cleanData, allData, 5, 1))